// -----------------------------------------------------------------------
// <copyright file="ShaderGeneratedSprite.cs" company="">
// Copyright (C) 2019 Matthew Razza & Will Graham
// </copyright>
// -----------------------------------------------------------------------

namespace CelestialEngine.Game
{
    using CelestialEngine.Core;
    using CelestialEngine.Core.Shaders;
    using Microsoft.Xna.Framework;

    /// <summary>
    /// A sprite whose color and normal maps are generated by a shader.
    /// </summary>
    public abstract class ShaderGeneratedSprite : SpriteBase
    {
        private readonly Vector2 dimensions;

        /// <summary>
        /// Initializes a new instance of the <see cref="ShaderGeneratedSprite" /> class with the specified arguments.
        /// </summary>
        /// <param name="world">The <see cref="World"/> in which this sprite lives.</param>
        /// <param name="dimensions">The dimensions (size) of the sprite in world units expressed as a <see cref="Vector2"/>.</param>
        /// <param name="shader">The <see cref="Shader"/> to use for rendering.</param>
        public ShaderGeneratedSprite(World world, Vector2 dimensions, Shader shader) : base(world)
        {
            this.dimensions = dimensions;
            this.Shader = shader;
        }

        /// <inheritdoc />
        public sealed override RectangleF SpriteWorldRenderBounds => new RectangleF(this.Position, this.dimensions.X, this.dimensions.Y);

        /// <summary>
        /// Gets the shader used to render the sprite.
        /// </summary>
        public Shader Shader { get; }

        /// <inheritdoc />
        public override void LoadContent(ExtendedContentManager contentManager)
        {
            this.Shader.LoadContent(contentManager);
        }

        /// <inheritdoc />
        public sealed override void DrawColorMap(GameTime gameTime, DeferredRenderSystem renderSystem)
        {
            renderSystem.BeginRender(this.Shader);
            this.ConfigureAndApplyColorShader(gameTime, renderSystem);
            renderSystem.DrawFilledRectangle(this.SpriteWorldRenderBounds, Color.White, this.Rotation);
            renderSystem.EndRender();
        }

        /// <inheritdoc />
        public sealed override void DrawNormalMap(GameTime gameTime, DeferredRenderSystem renderSystem)
        {
            renderSystem.BeginRender(this.Shader);
            this.ConfigureAndApplyNormalShader(gameTime, renderSystem);
            renderSystem.DrawFilledRectangle(this.SpriteWorldRenderBounds, Color.White, this.Rotation);
            renderSystem.EndRender();
        }

        /// <inheritdoc />
        public sealed override void DrawOptionsMap(GameTime gameTime, DeferredRenderSystem renderSystem)
        {
            // TODO: Options map stuff.
            return;
        }

        /// <summary>
        /// Configures and applies the shader for the color map.
        /// </summary>
        /// <param name="gameTime">Time passed since the last call.</param>
        /// <param name="renderSystem"><see cref="DeferredRenderSystem"/> to render with.</param>
        /// <remarks>
        /// Be sure to call `Shader.ConfigureShader` before setting values for any parameters.
        /// Ensure to apply the correct pass and technique.
        /// </remarks>
        protected abstract void ConfigureAndApplyColorShader(GameTime gameTime, DeferredRenderSystem renderSystem);

        /// <summary>
        /// Configures and applies the shader for the normal map.
        /// </summary>
        /// <param name="gameTime">Time passed since the last call.</param>
        /// <param name="renderSystem"><see cref="DeferredRenderSystem"/> to render with.</param>
        /// <remarks>
        /// Be sure to call `Shader.ConfigureShader` before setting values for any parameters.
        /// Ensure to apply the correct pass and technique.
        /// </remarks>
        protected abstract void ConfigureAndApplyNormalShader(GameTime gameTime, DeferredRenderSystem renderSystem);
    }
}
